# 使用 DDL 语句创建和管理表

## 分类主要的数据库对象

数据库内存在各种不同类型的对象。所有对象都有名称，并且所有对象都属于某个人。“某个人”就是指数据库用户。用户拥有的对象就是它们的模式（schema）。对象的名称必须符合某些规则。

### 对象类型

下面这个查询列出某个特定数据库中存在的对象类型

```sql
SELECT OBJECT_TYPE, count(OBJECT_TYPE)
FROM DBA_OBJECTS
GROUP BY OBJECT_TYPE
ORDER BY OBJECT_TYPE
```

另外两个视图是 USER_OBJECTS 和 ALL_OBJECTS，前者会显示你拥有的所有对象，后者会显示你能够访问的所有对象。

SQL 编程人员最感兴趣的对象是包含数据或者能够访问数据的对象。
- 表
- 视图
- 同义词
- 索引
- 序列

### 用户和模式

在 Oracle 环境中，用户就是能够连接到数据库的人，用户拥有用户名和密码。模式是一个容器，它包含用户拥有的对象。创建用户时，也会创建它们的模式，模式最初是空的。

有些模式一直是空的，这样的用户会获得许可来使用代码和访问其他用户拥有的其他模式中的数据。其他用户可能于此相反：他们拥有许多对象，但实际上从来不会登录数据库。这些模式可用作其他用户访问的代码和数据的仓库。

在创建数据库时会自动创建许多用户（和它们的相关模式）。主要用户是 SYS 和 SYSTEM。用户 SYS 用户拥有数据字典：这是一组表（在 SYS 模式中），定义数据库及其内容。SYS 还拥有几百个 `PL/SQL` 程序包：这是供数据库管理员和开发人员使用的代码。使用 DML 命令修改 SYS 模式中的对象，会存在破坏数据字典的风险，导致灾难性的后果。可以通过运行 DDL 命令来更新数据字典。SYSTEM 模式存储其他各种用于管理和监控的对象。

依据在数据库创建过程中选中的选项，可能有更多已经创建的用户。这些用户通过各种数据库选项来存储所需的代码和数据。

### 命名模式对象

模式对象是归用户所有的对象。所有模式对象的名称都必须符合某些规则：
- 名称可以是 1~30 个字符（除了数据库链接名之外，它可能达到 128 个字符）
- 保留字（例如 SELECT）不能用作对象名字
- 所有名称必须以从“A”到“Z”的字母开头
- 名称中的字符只能是字母、数字、下划线（\_）、美元符号（\$）或者哈希符号（\#）

通过将名称包含在双引号内，所有这些规则（除长度之外）都可以打破，但在其后使用对象时，也一定要用双引号指定它。注意，同样的限制也适用于列名称。

对象名总是区分大小写。

### 对象名称空间

通常说对象的唯一标识符是指对象名称，前面加上模式名。名称空间（namespace）定义一组对象类型，在这个组里面，所有命称都必须由模式和名称唯一标识。不同名称空间中的对象可以共享相同的名。

以下这些对象类型都共享相同的名称空间
- 表
- 视图
- 序列
- 私有同义词

在相同的模式中，上面四种对象类型名称不能相同。

索引和约束都有自己的名称空间，因此，索引的名称可以与表名相同，即使是在同一个模式中。

## 回顾表结构

表是保持行的二维结构。Oracle 数据库允许改变这种二维模型。这些列可以定义为嵌套的表。每个表都作为数据字典中的一个定义而存在。在创建表的过程中，在数据库内会为表分配有限的空间（称为盘区）。盘区填满之后，数据库会给表再分配一个盘区。删除行，分配给表的盘区任会保留。如果删除或者截断表，就会释放这些盘区，并返回给数据库以便重用。

## 列举列可以的数据类型

在 12c 数据库中，引入了一个新的系统参数 MAX_STRING_SIZE，当把字符串数据类型从默认值 STANDARD 改变为 EXTENDED 时，该参数允许字符串类型的长度比以前版本中的更长些。

适用于字符数据的数据类型

|数据类型|名称|长度|描述|
|:-|:-|:-|:-|
|VARCHAR2|可变长度的字符数据|字节，1-4000（STANDARD）<BR>字节，1-32767（EXTENDED）|数据保存在数据库字符集中|
|NVARCHAR2||同 VARCHAR2|数据保存在可选的国家语言字符集中，它是许可的 UNICODE 字符集之一|
|CHAR|固定长度的字符数据|字节，1-2000|数据保存在数据库字符集中|

注意

为了与 ISO/ANSI 兼容，可以指定 VARCHAR 数据类型，但这种类型的所有列都会自动转换为 VARCHAR2。

适用于二进制数据的数据类型

|数据类型|名称|长度|描述|
|:-|:-|:-|:-|
|RAW|可变长度的二进制数据|字节，1-4000（STANDARD）<BR>字节，1-32767（EXTENDED）|与 CHAR 和 VARCHAR2 数据类型不同，Oracle Net 不会将 RAW 数据从数据库<br>的字符集转换为 SELECT 上用户进程的字符集，它们都是可变长度的数据类型|

适用于数字数据的数据类型，它们都是可变长度的数据类型

|数据类型|名称|长度|描述|
|:-|:-|:-|:-|
|NUMBER|数字数据|精度范围是 1~38 位<br>刻度范围是 -84~127||
|FLOAT|浮点数，这是一个 ANSI 数据类型|精度为：<br>二进制 126 位 或者<br>十进制 38 位|Oracle 还提供BINARY_FLOAT 和 BINARY_DOUBLE 作为备选|
|INTEGER||等同于 NUMBER，刻度为零||

适用于日期和时间数量的数据类型，它们都是固定长度的数据类型

|数据类型|名称|长度|描述|
|:-|:-|:-|:-|
|DATE||字节，零（如果列为空）或者 7 字节<br>有效刻度：<br>`January 1,4712 BC` 到<br>`December 31,9999 AD`|所有 DATE 数据都包含世纪、年、月、日、时、分和秒|
|TIMESTAMP||字节，零（如果列为空）或者最长为 11 字节，取决于指定的精度<br>对于秒，精度最多为 9 个小数位，默认为 6 位||
|TIMESTAMP WITH TIMEZONE||同 TIMESTAMP 一样，<br>长度依据精度可能达到 13 个字节|使用保存记录时所引用的时区来保存数据。<br>这种数据类型让 Oracle 通过将两个时间规范化到 UTC 来确定它们之间的差，即使这两个时间在不同的时区。|
|TIMESTAMP WITH LOCAL TIMEZONE||同 TIMESTAMP 一样|数据被规范化为保存它的数据库时区。<br>当检索时，将它规范化为用户进程选择它时所处的时区。|
|INTERVAL YEAR TO MONTH|||用于记录两个 DATE 或者 TIMESTAMP 之间年和月的时间间隔|
|INTERVAL DAY TO SECOND|||用于记录两个 DATE 或者 TIMESTAMP 之间日和分的时间间隔|

大对象数据类型

|数据类型|名称|长度|描述|
|:-|:-|:-|:-|
|CLOB||大小没有限制：<br>(4GB - 1) 乘以数据库块的大小|保存在数据库字符集中的字符数据|
|NCLOB||同 CLOB 一样|数据存储在可选的国家语言字符集中，它是许可的 UNICODE 字符集之一|
|BLOB||同 CLOB 一样|二进制数据不会进行由 Oracle Net 执行的字符集转换|
|BFILE||文件的大小限制为 4GB|一个定位器，它指向存储在数据库服务器操作系统上的文件|
|LONG||大小可达 2GB|LONG 的所有功能都由 CLOB 提供：不能在现代数据库中使用 LONG，如果数据库有这种类型的列，应该将它们转换为 CLOB。<br>在一个表中只能有一个 LONG 列。|
|LONG RAW||同 LONG 一样|Oracle Net 不会转换这个二进制数据。所有 LONG RAW 列都应该转换为 BLOB|
|ROWID|||按 Base64 编码的值，它是一个指针，指向表中行的位置。ROWID 中加密的内容是准确的物理地址。<br>ROWID 是 Oracle 专有的数据类型，除非特别选择，否则不可见。|

VARCHAR2 数据类型必须用一个数来限定，这个数表示列的最大长度。

可以使用精度和刻度来限制 NUMBER 数据类型。精度用于设定小数中最大有效数字个数，有效数字是指从数字中最左面非零数字起，至最右面的最小数字。刻度是指从小数点到右面最小数字的数字个数。正刻度是指小数点右面的有效数字至最小数字（包含最小数字）的有效数字个数，负刻度是指小数点左侧数字至最小有效数字（不包括最小数字）的有效数字个数。

DATE 数据类型总是包括世纪、年、月、日、时、分和秒，必须指定年、月和日，如果省略时、分和秒，那么它们会默认为午夜。

## 创建简单的表

最简单的是堆表。堆是随机排列的可变长度的行。输入行的顺序和排列行的顺序之间没有关联。

更高级的表结构
- 按索引组织的表：按索引键的顺序存储行
- 索引集群：可以反规范化父-子关系表，这样来自不同表的相关行就可以存储在一起
- 哈希集群：要求随机分布行，这样会打破依据条目序列的任何排序
- 分区表：以单独的物理结构（分区）存储行，根据列的值分配行

使用更高级的表结构对 SQL 没有任何影响。针对这些选项定义的表执行的每个 SQL 语句都会返回相同的结果。

### 使用列规范创建表

要创建标准的堆表，可以使用下面的语法

```
CREATE TABLE [schema.]table [ORGANIZATION HEAP]
(column datatype [DEFAULT expression]
[, column datatype [DEFAULT expression] ...]);
```

示例

```
CREAT TABLE SCOTT.EMP
(EMPNO NUMBER(4),
EMANE VARCHAR2(10),
HIREDATE DATE DEFAULT TRUNC(SYSDATE),
SAL NUMBER(7, 2),
COMM NUMBER(7, 2) DEFAULT 0.03);
```

注意

DEFAULT 子句可能很有用，但它的功能有限。不能使用子查询来生成默认值，只能指定字面值或者函数。

### 从子查询创建表

```
CREATE TABLE [schema.]table AS subquery;
```

示例

```sql
CREATE TABLE employees_copy AS
SELECT *
FROM employees;
```

创建一个没有行的表

```sql
CREATE TABLE no_emps AS
SELECT *
FROM employees
WHERE 1=2
```

### 在创建表后变更表定义

示例

```sql
-- 添加列
ALTER TABLE emp
ADD (job_id number);


-- 修改列
ALTER TABLE emp
MODIFY (comm number(4, 2) FEFAULT 0.05);


-- 删除列
ALTER TABLE emp
DROP COLUMN comm;


-- 将列标记为未使用
ALTER TABLE emp
SET UNUSED COLUMN job_id;


-- 重命名列
ALTER TABLE emp
RENAME COLUMN hiredate TO recruited;


-- 将表标记为只读
ALTER TABLE emp
READ ONLY;


-- 删除所有未使用的列
ALTER TABLE tablename
DROP UNUSED COLUMNS;
```

所有这些变更都是包含内置 COMMIT 的 DDL 命令，因此它们是不可逆的，如果表上有活动事务它们就会失败。除了删除列之外，其他都是瞬间的。删除列可能是一个耗时的实践，因为删除列之后，必须重新构建各行来删除列的数据。SET UNUSED 命令使这些列不存在。

对于 DML 命令而言，将表标记为只读会产生错误，但还是能够删除表。DROP 命令实际上不影响表，它影响数据字典中那些定义该表的表，这些表不是只读的。

### 删除和截断表

TRUNCATE TABLE 命令能够删除表中的所有行，同时保持表定义不变。DROP TABLE 删除表中所有行，同时会删除表定义。

```
DROP TABLE [schema.]tablename;
```

如果没有指定模式，那么在当前登录模式中名为 tablename 的表就会被删除。也可能删除在为其他表而定义的外键约束中引用的表。

Oracle 12c 中引入了回收站（recycle bin）选项，默认情况下，该选择处于激活状态。这允许恢复任何已删除的表，除非使用 PURGE 选项删除表，或者回收站选项已经处于禁用状态。

## 讨论在创建表时如何创建约束

表约束是一种方式，通过这种方式，数据库可以强化业务规则，确保数据符合由定义应用程序数据结构的系统分析确定的实体-关系模型。

当使用定义的约束对表执行任何 DML 时，如果 DML 违背约束，那么就会自动回滚整个语句。记住，影响许多行的 DML 语句在遇到特定行的约束问题之前，可能会部分成功。如果语句是多语句事务的一部分，那么已经成功的语句会保持不变，但不会提交它。

### 约束的类型

Oracle 数据库支持的约束类型包括
- UNIQUE
- NOT NULL
- PRIMARY KEY
- FOREIGN KEY
- CHECK

约束都有名称。良好的实践是使用标准的命名约定指定名称，但如果没有显式的对它们进行命名，Oracle 会生成名称。

1. 唯一约束

   唯一约束要求表中每一行的列（或者列的组合）的值必须不同。如果基于单列，就称为键列（key column）。如果约束由多列组成，就称为复合键（composite key）唯一约束，这些列的数据类型不一定相同，在表定义中也不一定相邻。

   唯一约束可以在键列中输入 NULL 值，可以在键列中有任意数量的行包含 NULL 值。因此依据键列选择行可以确保只返回一行，除非搜素 NULL，这种情况会返回所有键列为 NULL 的行。

   索引会加强唯一约束。在定义唯一索引时，Oracle 会查找键列的索引，如果索引不存在，就会创建一个。当插入列时，Oracle 会搜索索引，看键列的值是否存在，如果存在，它就拒绝插入。索引的结构不包含 NULL 值，这就是允许许多行包含 NULL 的原因，它们不存在于索引中。索引能够提高性能。然而，`WHERE key_column IS NULL` 不能使用索引，因为索引不包含 NULL 值，因此总是会扫描整个表。

1. 非空约束

   非空约束要求指定输入键列的值。在每一列都定义非空约束，不能为一组列定义一个非空约束。

   在没有为非空约束的列指定值的情况下插入行，会导致错误。当创建表时，在列上包含 DEFAULT 子句，就看可以不需要指定值。

1. 主键约束

   主键约束是定位表中单行的方法。关系数据库范例包括一个每个表都应该有主键的要求，该主键是一个用来区分每一行的列（或者列组合）。Oracle 数据库允许表没有主键。

   主键约束是唯一约束和非空约束的联合。一个表只有有一个主键。一个表可以有许多个唯一约束和非空列。

1. 外键约束

   在父-子关系的子表上定义外键约束。该约束要求子表中的列（或者列组合）对应父表中的主键列。这些列的名称不一定相同，但它们的数据类型必须相同。外键约束定义数据库的关系结构：在第三范式中，连接表的多对一关系。

   如果父表有唯一约束和（或者不是）主键约束，那么这些列可用作外键约束的基础，即使它们可以为空值。

   外键约束允许在约束的列中出现空值。可以在子表中插入包含空值外键列的行，即使父表中没有行包含空值。这会创建孤行，可能产生可怕的混淆。通常，唯一约束中的所有列和外键约束中的所有列最好使用非空约束定义，这通常是一个行业要求。

   如果在子表中插入行，而在父表中没有匹配的行，这样会出现错误。同样，如果删除父表中的行，而子表中有行在引用它，那么也会出现错误。有两种方法可以改变这种行为。第一，可以创建 `ON DELETE CASCADE` 约束。这意味着，如果删除父表中的行，Oracle 会搜素子表，查找所有匹配行，并删除它们，这会自动发生。更温和的方法是创建 `ON DELETE SET NULL` 约束。这意味着，如果删除父表中的行，Oracle 会搜索子表，查找所有匹配行，并将外键列设置为 NULL。这意味着子行可能是孤行，但它依然存在。如果子表中的列也有非空约束，那么从父表中删除就会失败。

   在外键关系中不可能删除或者截断父表，即使子表中没有行。

   考点

   子表中的外键约束必须引用父表中唯一约束或者主键约束的列。

   外键约束的变体是自引用外键约束。在它定义的条件中，父行和子行存在于同一个表中。

1. 检查约束

   检查约束用来实施简单规则。该规则必须是赋值为 TRUE 或者 FALSE 的表达式。规则可以引用作为字面值的绝对值，或者引用同一行中的其他列，也可以使用一些函数。一列可以应用多个检索约束，但不能使用子查询来评估值是否许可，也不能使用像 SYSDATE 这样的函数。

   注意

   其实非空约束就是预配置的检查约束。

### 定义约束

当创建表时可以定义约束，也可在以后将它添加到表中。在创建表时定义约束，可以接着它引用的列来定义约束或者在表定义的结尾定义约束。使用后一种方法更加灵活。如果依次定义约束，就不可能定义引用两列的外键约束，或者引用除被约束的列之外的列的检查约束，但如果在表的结尾定义约束，这两者都可以实现。

对于需要索引的约束（唯一约束和主键约束）而言，如果在创建表时定义约束，就会创建表的索引。

```sql
CREATE TABLE dept(
    deptno NUMBER(2, 0) 
        CONSTRAINT dept_deptno_pk PRIMARY KEY 
        CONSTRAINT dept_deptno_ck CHECK (deptno BETWEEN 10 AND 90),
    danme VARCHAR2(20)
        CONSTRAINT dept_dname_nn NOT NULL
);
```

```sql
CREATE TABLE emp(
    empno NUMBER(4, 0)
        CONSTRAINT emp_empno_pk PRIMARY KEY,
    ename VARCHAR2(20)
        CONSTRAINT emp_ename_nn NO NULL,
    mgr NUMBER(4, 0)
        CONSTRAINT emp_mgr_fk REFERENCES emp(empno),
    dob DATE,
    hiredate DATE,
    deptno NUMBER(2, 0)
        CONSTRAINT emp_deptno_fk REFERENCES dept(deptno) ON DELETE SET NULL,
    email VARCHAR2(30)
        CONSTRAINT emp_email_uk UNIQUE,
    CONSTRAINT emp_hiredate_ck CHECK (hiredate >= dob + 365*16),
    CONSTRAINT emp_email_ck CHECK ((INSTR(email, '@')>0) AND (INSTR(email, '.')>0))
);
```

前面的示例说明在创建表时定义约束的几种可能。下面是没有讨论的几种可能。
- 对于唯一约束和主键约束，控制索引的创建。
- 定义是在插入时检查约束（这是默认行为）还是在提交事务后检查它。
- 说明时实施约束（这是默认行为）还是禁用约束。

可以创建没有约束的表，然后使用 ALTER TABLE 命令添加约束。最终结构可能相同，但这种方法使代码缺少自说明性。

```sql
ALTER TABLE emp
ADD CONSTRAINT emp_pk PRIMARY KEY (empno);
```