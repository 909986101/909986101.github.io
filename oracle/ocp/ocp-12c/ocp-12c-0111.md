# 使用 DDL 语句创建和管理表

## 分类主要的数据库对象

数据库内存在各种不同类型的对象。所有对象都有名称，并且所有对象都属于某个人。“某个人”就是指数据库用户。用户拥有的对象就是它们的模式（schema）。对象的名称必须符合某些规则。

### 对象类型

下面这个查询列出某个特定数据库中存在的对象类型

```sql
SELECT OBJECT_TYPE, count(OBJECT_TYPE)
FROM DBA_OBJECTS
GROUP BY OBJECT_TYPE
ORDER BY OBJECT_TYPE
```

另外两个视图是 USER_OBJECTS 和 ALL_OBJECTS，前者会显示你拥有的所有对象，后者会显示你能够访问的所有对象。

SQL 编程人员最感兴趣的对象是包含数据或者能够访问数据的对象。
- 表
- 视图
- 同义词
- 索引
- 序列

### 用户和模式

在 Oracle 环境中，用户就是能够连接到数据库的人，用户拥有用户名和密码。模式是一个容器，它包含用户拥有的对象。创建用户时，也会创建它们的模式，模式最初是空的。

有些模式一直是空的，这样的用户会获得许可来使用代码和访问其他用户拥有的其他模式中的数据。其他用户可能于此相反：他们拥有许多对象，但实际上从来不会登录数据库。这些模式可用作其他用户访问的代码和数据的仓库。

在创建数据库时会自动创建许多用户（和它们的相关模式）。主要用户是 SYS 和 SYSTEM。用户 SYS 用户拥有数据字典：这是一组表（在 SYS 模式中），定义数据库及其内容。SYS 还拥有几百个 `PL/SQL` 程序包：这是供数据库管理员和开发人员使用的代码。使用 DML 命令修改 SYS 模式中的对象，会存在破坏数据字典的风险，导致灾难性的后果。可以通过运行 DDL 命令来更新数据字典。SYSTEM 模式存储其他各种用于管理和监控的对象。

依据在数据库创建过程中选中的选项，可能有更多已经创建的用户。这些用户通过各种数据库选项来存储所需的代码和数据。

### 命名模式对象

模式对象是归用户所有的对象。所有模式对象的名称都必须符合某些规则：
- 名称可以是 1~30 个字符（除了数据库链接名之外，它可能达到 128 个字符）
- 保留字（例如 SELECT）不能用作对象名字
- 所有名称必须以从“A”到“Z”的字母开头
- 名称中的字符只能是字母、数字、下划线（\_）、美元符号（\$）或者哈希符号（\#）

通过将名称包含在双引号内，所有这些规则（除长度之外）都可以打破，但在其后使用对象时，也一定要用双引号指定它。注意，同样的限制也适用于列名称。

对象名总是区分大小写。

### 对象名称空间

通常说对象的唯一标识符是指对象名称，前面加上模式名。名称空间（namespace）定义一组对象类型，在这个组里面，所有命称都必须由模式和名称唯一标识。不同名称空间中的对象可以共享相同的名。

以下这些对象类型都共享相同的名称空间
- 表
- 视图
- 序列
- 私有同义词

在相同的模式中，上面四种对象类型名称不能相同。

索引和约束都有自己的名称空间，因此，索引的名称可以与表名相同，即使是在同一个模式中。

## 回顾表结构

表是保持行的二维结构。Oracle 数据库允许改变这种二维模型。这些列可以定义为嵌套的表。每个表都作为数据字典中的一个定义而存在。在创建表的过程中，在数据库内会为表分配有限的空间（称为盘区）。盘区填满之后，数据库会给表再分配一个盘区。删除行，分配给表的盘区任会保留。如果删除或者截断表，就会释放这些盘区，并返回给数据库以便重用。

## 列举列可以的数据类型

在 12c 数据库中，引入了一个新的系统参数 MAX_STRING_SIZE，当把字符串数据类型从默认值 STANDARD 改变为 EXTENDED 时，该参数允许字符串类型的长度比以前版本中的更长些。

适用于字符数据的数据类型

|数据类型|名称|长度|描述|
|:-|:-|:-|:-|
|VARCHAR2|可变长度的字符数据|字节，1-4000（STANDARD）<BR>字节，1-32767（EXTENDED）|数据保存在数据库字符集中|
|NVARCHAR2||同 VARCHAR2|数据保存在可选的国家语言字符集中，它是许可的 UNICODE 字符集之一|
|CHAR|固定长度的字符数据|字节，1-2000|数据保存在数据库字符集中|

注意

为了与 ISO/ANSI 兼容，可以指定 VARCHAR 数据类型，但这种类型的所有列都会自动转换为 VARCHAR2。

适用于二进制数据的数据类型

|数据类型|名称|长度|描述|
|:-|:-|:-|:-|
|RAW|可变长度的二进制数据|字节，1-4000（STANDARD）<BR>字节，1-32767（EXTENDED）|与 CHAR 和 VARCHAR2 数据类型不同，Oracle Net 不会将 RAW 数据从数据库<br>的字符集转换为 SELECT 上用户进程的字符集，它们都是可变长度的数据类型|

适用于数字数据的数据类型，它们都是可变长度的数据类型

|数据类型|名称|长度|描述|
|:-|:-|:-|:-|
|NUMBER|数字数据|精度范围是 1~38 位<br>刻度范围是 -84~127||
|FLOAT|浮点数，这是一个 ANSI 数据类型|精度为：<br>二进制 126 位 或者<br>十进制 38 位|Oracle 还提供BINARY_FLOAT 和 BINARY_DOUBLE 作为备选|
|INTEGER||等同于 NUMBER，刻度为零||

适用于日期和时间数量的数据类型，它们都是固定长度的数据类型

|数据类型|名称|长度|描述|
|:-|:-|:-|:-|
|DATE||字节，零（如果列为空）或者 7 字节<br>有效刻度：<br>`January 1,4712 BC` 到<br>`December 31,9999 AD`|所有 DATE 数据都包含世纪、年、月、日、时、分和秒|
|TIMESTAMP||字节，零（如果列为空）或者最长为 11 字节，取决于指定的精度<br>对于秒，精度最多为 9 个小数位，默认为 6 位||
|TIMESTAMP WITH TIMEZONE||同 TIMESTAMP 一样，<br>长度依据精度可能达到 13 个字节|使用保存记录时所引用的时区来保存数据。<br>这种数据类型让 Oracle 通过将两个时间规范化到 UTC 来确定它们之间的差，即使这两个时间在不同的时区。|
|TIMESTAMP WITH LOCAL TIMEZONE||同 TIMESTAMP 一样|数据被规范化为保存它的数据库时区。<br>当检索时，将它规范化为用户进程选择它时所处的时区。|
|INTERVAL YEAR TO MONTH|||用于记录两个 DATE 或者 TIMESTAMP 之间年和月的时间间隔|
|INTERVAL DAY TO SECOND|||用于记录两个 DATE 或者 TIMESTAMP 之间日和分的时间间隔|

大对象数据类型

|数据类型|名称|长度|描述|
|:-|:-|:-|:-|
|CLOB||大小没有限制：<br>(4GB - 1) 乘以数据库块的大小|保存在数据库字符集中的字符数据|
|NCLOB||同 CLOB 一样|数据存储在可选的国家语言字符集中，它是许可的 UNICODE 字符集之一|
|BLOB||同 CLOB 一样|二进制数据不会进行由 Oracle Net 执行的字符集转换|
|BFILE||文件的大小限制为 4GB|一个定位器，它指向存储在数据库服务器操作系统上的文件|
|LONG||大小可达 2GB|LONG 的所有功能都由 CLOB 提供：不能在现代数据库中使用 LONG，如果数据库有这种类型的列，应该将它们转换为 CLOB。<br>在一个表中只能有一个 LONG 列。|
|LONG RAW||同 LONG 一样|Oracle Net 不会转换这个二进制数据。所有 LONG RAW 列都应该转换为 BLOB|
|ROWID|||按 Base64 编码的值，它是一个指针，指向表中行的位置。ROWID 中加密的内容是准确的物理地址。<br>ROWID 是 Oracle 专有的数据类型，除非特别选择，否则不可见。|

VARCHAR2 数据类型必须用一个数来限定，这个数表示列的最大长度。

可以使用精度和刻度来限制 NUMBER 数据类型。精度用于设定小数中最大有效数字个数，有效数字是指从数字中最左面非零数字起，至最右面的最小数字。刻度是指从小数点到右面最小数字的数字个数。正刻度是指小数点右面的有效数字至最小数字（包含最小数字）的有效数字个数，负刻度是指小数点左侧数字至最小有效数字（不包括最小数字）的有效数字个数。

DATE 数据类型总是包括世纪、年、月、日、时、分和秒，必须指定年、月和日，如果省略时、分和秒，那么它们会默认为午夜。

## 创建简单的表

最简单的是堆表。堆是随机排列的可变长度的行。输入行的顺序和排列行的顺序之间没有关联。

更高级的表结构
- 按索引组织的表：按索引键的顺序存储行
- 索引集群：可以反规范化父-子关系表，这样来自不同表的相关行就可以存储在一起
- 哈希集群：要求随机分布行，这样会打破依据条目序列的任何排序
- 分区表：以单独的物理结构（分区）存储行，根据列的值分配行

使用更高级的表结构对 SQL 没有任何影响。针对这些选项定义的表执行的每个 SQL 语句都会返回相同的结果。

### 使用列规范创建表

要创建标准的堆表，可以使用下面的语法

```
CREATE TABLE [schema.]table [ORGANIZATION HEAP]
(column datatype [DEFAULT expression]
[, column datatype [DEFAULT expression] ...]);
```

示例

```
CREAT TABLE SCOTT.EMP
(EMPNO NUMBER(4),
EMANE VARCHAR2(10),
HIREDATE DATE DEFAULT TRUNC(SYSDATE),
SAL NUMBER(7, 2),
COMM NUMBER(7, 2) DEFAULT 0.03);
```

注意

DEFAULT 子句可能很有用，但它的功能有限。不能使用子查询来生成默认值，只能指定字面值或者函数。

### 从子查询创建表

```
CREATE TABLE [schema.]table AS subquery;
```

示例

```sql
CREATE TABLE employees_copy AS
SELECT *
FROM employees;
```

创建一个没有行的表

```sql
CREATE TABLE no_emps AS
SELECT *
FROM employees
WHERE 1=2
```

### 在创建表后变更表定义

示例

```sql
-- 添加列
ALTER TABLE emp
ADD (job_id number);


-- 修改列
ALTER TABLE emp
MODIFY (comm number(4, 2) FEFAULT 0.05);


-- 删除列
ALTER TABLE emp
DROP COLUMN comm;


-- 将列标记为未使用
ALTER TABLE emp
SET UNUSED COLUMN job_id;


-- 重命名列
ALTER TABLE emp
RENAME COLUMN hiredate TO recruited;


-- 将表标记为只读
ALTER TABLE emp
READ ONLY;


-- 删除所有未使用的列
ALTER TABLE tablename
DROP UNUSED COLUMNS;
```

所有这些变更都是包含内置 COMMIT 的 DDL 命令，因此它们是不可逆的，如果表上有活动事务它们就会失败。除了删除列之外，其他都是瞬间的。删除列可能是一个耗时的实践，因为删除列之后，必须重新构建各行来删除列的数据。SET UNUSED 命令使这些列不存在。

对于 DML 命令而言，将表标记为只读会产生错误，但还是能够删除表。DROP 命令实际上不影响表，它影响数据字典中那些定义该表的表，这些表不是只读的。

### 删除和截断表

TRUNCATE TABLE 命令能够删除表中的所有行，同时保持表定义不变。DROP TABLE 删除表中所有行，同时会删除表定义。

```
DROP TABLE [schema.]tablename;
```

如果没有指定模式，那么在当前登录模式中名为 tablename 的表就会被删除。也可能删除在为其他表而定义的外键约束中引用的表。

Oracle 12c 中引入了回收站（recycle bin）选项，默认情况下，该选择处于激活状态。这允许恢复任何已删除的表，除非使用 PURGE 选项删除表，或者回收站选项已经处于禁用状态。

## 讨论在创建表时如何创建约束

表约束是一种方式，通过这种方式，数据库可以强化业务规则，确保数据符合由定义应用程序数据结构的系统分析确定的实体-关系模型。

当使用定义的约束对表执行任何 DML 时，如果 DML 违背约束，那么就会自动回滚整个语句。记住，影响许多行的 DML 语句在遇到特定行的约束问题之前，可能会部分成功。如果语句是多语句事务的一部分，那么已经成功的语句会保持不变，但不会提交它。

### 约束的类型

Oracle 数据库支持的约束类型包括
- UNIQUE
- NOT NULL
- PRIMARY KEY
- FOREIGN KEY
- CHECK

约束都有名称。良好的实践是使用标准的命名约定指定名称，但如果没有显式的对它们进行命名，Oracle 会生成名称。

1. 唯一约束